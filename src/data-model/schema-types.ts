// prefer using optionals for id's since they're generated by the database
// for any nullable fields, use 'null' instead of making it an optional field
// ex: date_submitted: Date | null; instead of date_submitted?: Date;
// this way, we can avoid having to set it to undefined if it comes back as null from the database


import { OrderStatus, UserRole } from "./enum-types";
import { BillingFields, QuantityIncoming, ShippingFields } from "./utility-types";

// object to determine auth
export type User = {
  id: string;
  email: string;
  password: string;
  role: UserRole;
  is_active: boolean;
};

// user-specific data that is subject to user manipulation which is
// why it is separate from the user object and user table
// IMPLEMENTATION NOTE: could be tables separate, but on front-end maintain a single user object
export type UserProfile = {
  profile_id: number;
  user_id: string;
  first_name: string;
  last_name: string;
  phone_num?: string;
  // customer_id?: string;
  // settings: {};
};

export type Customer = {
  customer_id: string;
  name: string;
  phone: string;
  email: string;
  // fields determined by admin
  type: string; // type: individual, business, non-profit
  account_num: string;
  credit_status: string; //
  // credit_limit will require parsing since it'll come back as a string from postgresql db query
  credit_limit: number;
  // fields determined by system
  date_updated: Date;
};
// NOTE TODO: consider making constructor function that returns a new customer object
/**
 * this type definition corresponds to the
 * CustomerShippingInformation table
 * @field shipping_info_id: number
 * @field customer_id: string
 */
export type CustomerShippingInformation = {
  shipping_info_id: number;
  customer_id: string;
  street: string;
  apt_num: string | null;
  city: string;
  state: string;
  zip: string;
  is_job_site: boolean;
  note: string | null;
};

/**
 * this type definition corresponds to the
 * CustomerBillingInformation table
 * @field billing_info_id: number
 * @field customer_id: string
 * @field street: string
 * @field apt_num: string | null
 */
export type CustomerBillingInformation = {
  billing_info_id: number;
  customer_id: string;
  street: string;
  apt_num: string | null;
  city: string;
  state: string;
  zip: string;
  payment_method: string;
  // payment_info: string; // stringified json object
  purchase_order: string;
  primary_contact_name: string;
  primary_contact_email: string;
  primary_contact_phone: string;
  fax_num: string | null;
  is_primary: boolean;
  is_active: boolean;
};

export type InventoryProduct = {
  product_id: string;
  type: string;
  image_url: string;
  alt: string;
  description: string;
  config_options: any;
  // unit price, eventually need to work in unit of measure
  // price: number;
  // unit:
  date_updated: Date;
  updated_by: string;
};

export type InventoryGlassItem = {
  glass_id: string;
  name: string;
  description: string;
  thickness: string[];
  shapes: string[];
  tint: string[];
  // IMPLEMENTATION NOTE:
  // shape, stock sheets, and different processes may have different min and max values
  // for length and width so check each part of config, and offer user option based on
  // the largest min smallest max across all parts of configuration
  compatible_products: string[];
  quantity_available: number;
  // supplier_id: string;
  quantity_incoming: QuantityIncoming; // jsonb
  date_updated: Date;
  updated_by: string;
};

// IMPLEMENTATION NOTE: for transferring to old system we need to split the order
//   - order_id + product_id + i/quantity
//   - 8634562 - 2345 - 1 / 10 

export type Order = {
  order_id: string; // uuid generated by db
  user_id: string; // user_id of user that created the order
  customer_id: string; // customer_id of the customer that placed the order
  order_name: string; // name of the order
  order_number: string; // unique order number
  shipping_data: ShippingFields; // object holding shipping data
  billing_data: BillingFields; // object holding billing data
  status: OrderStatus;
  amount: number;
  date_updated: Date;
  // Optional fields are useful for the front end, but the database will assign 'null' to them
  // On fetch, these fields come back null so we have to destruct the objects and set them to undefined if they are null
  date_submitted: Date | null;
  date_shipped: Date | null;
  date_delivered: Date | null;
};

// need a config object where all fields are optional
export type OrderItem = {
  order_item_id: number;
  order_id: string;
  product_type_id: string; // uuid of the product type
  // need product type name
  product_config: any; // jsonb
  quantity: number;
  note?: string;
};
/**
 * corresponds to the OrderInvoice table 
 * @field order_invoice_id: string
 * @field user_id: string
 * @field order_id: string
 * @field customer_id: string
 * @field invoice_number: string
 * @field status: string
 * @field amount: number
 * @field date_updated: Date
 */
export type OrderInvoice = {
  order_invoice_id: string;
  // user_id of the user that entered the order
  user_id: string;
  order_id: string;
  customer_id: string;
  invoice_number: string;
  status: string;
  amount: number;
  // date sent to customer 
  invoice_date: Date;
  date_updated: Date;
  // date paid by customer 
  // date_paid: Date;
};
