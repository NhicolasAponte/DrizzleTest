// prefer using optionals for id's since they're generated by the database
// for any nullable fields, use 'null' instead of making it an optional field
// ex: date_submitted: Date | null; instead of date_submitted?: Date;
// this way, we can avoid having to set it to undefined if it comes back as null from the database

import { OrderStatus, UserRole } from "./enum-types";

// object to determine auth
export type User = {
  id: string;
  email: string;
  password: string;
  role: UserRole;
  is_active: boolean;
};

// user-specific data that is subject to user manipulation which is
// why it is separate from the user object and user table
// IMPLEMENTATION NOTE: could be tables separate, but on front-end maintain a single user object
export type UserProfile = {
  profile_id: number;
  user_id: string;
  first_name: string;
  last_name: string;
  phone_num?: string;
  // customer_id?: string;
  // settings: {};
};

export type Customer = {
  customer_id: string;
  name: string;
  phone: string;
  email: string;
  // fields determined by admin
  type: string; // type: individual, business, non-profit
  account_num: string;
  credit_status: string; //
  // credit_limit will require parsing since it'll come back as a string from postgresql db query
  credit_limit: number;
  // fields determined by system
  date_created: Date;
  date_updated: Date;
};
// NOTE TODO: consider making constructor function that returns a new customer object
/**
 * this type definition corresponds to the 
 * CustomerShippingInformation table 
 * @field shipping_info_id: number 
 * @field customer_id: string 
 */
export type CustomerShippingInformation = {
  shipping_info_id: number;
  customer_id: string;
  street: string;
  apt_num: string | null;
  city: string;
  state: string;
  zip: string;
  is_job_site: boolean;
  note: string | null;
};
/**
 * ShippingFields is the data type made up of the required 
 * fields for the Shipping Form component 
 */
export type ShippingFields = Omit<
  CustomerShippingInformation,
  "shipping_info_id" | "customer_id"
>;
/**
 * union type of CustomerShippingInformation and ShippingFields 
 */
export type ShippingData = CustomerShippingInformation | ShippingFields;

/**
 * this type definition corresponds to the 
 * CustomerBillingInformation table 
 * @field billing_info_id: number 
 * @field customer_id: string
 * @field street: string
 * @field apt_num: string | null
 */
export type CustomerBillingInformation = {
  billing_info_id: number;
  customer_id: string;
  street: string;
  apt_num: string | null;
  city: string;
  state: string;
  zip: string;
  payment_method: string;
  // payment_info: string; // stringified json object
  purchase_order: string;
  primary_contact_name: string;
  primary_contact_email: string;
  primary_contact_phone: string;
  fax_num: string | null;
  is_primary: boolean;
  is_active: boolean;
};
/**
 * BillingFields is the data type made up of the required 
 * fields for the Billing Form component 
 */
export type BillingFields = Omit<
  CustomerBillingInformation,
  "billing_info_id" | "customer_id"
>;
/**
 * union type of CustomerBillingInformation and BillingFields 
 */
export type BillingData = CustomerBillingInformation | BillingFields;

export type InventoryProduct = {
  product_id: string;
  type: string;
  image_url: string;
  alt: string;
  description: string;
  config_options: any;
  // unit price, eventually need to work in unit of measure
  // price: number;
  // unit:
  date_created: Date;
  date_updated: Date;
  updated_by: string;
};

export type InventoryGlassItem = {
  glass_id: string;
  name: string;
  description: string;
  thickness: string[];
  shapes: string[];
  tint: string[];
  compatible_products: string[];
  quantity_available: number;
  // supplier_id: string;
  quantity_incoming: quantityIncoming; // jsonb
  date_created: Date;
  date_updated: Date;
  updated_by: string;
};

// IMPLEMENTATION NOTE:
// shape, stock sheets, and different processes may have different min and max values
// for length and width so check each part of config, and offer user option based on
// the largest min smallest max across all parts of configuration

interface quantityIncoming {
  quantity_incoming: number;
  restock_order_id: string;
  supplier_id: string;
  expected_arrival_date: Date;
}
// NOTE TODO: make derived fields optional
// id, order number, amount
export type Order = {
  order_id: string; // uuid generated by db
  created_by: string; // user_id of user that created the order
  customer_id: string; // customer_id of the customer that placed the order
  order_name: string; // name of the order
  order_number: string; // unique order number
  shipping_data: ShippingFields; // object holding shipping data
  billing_data: BillingFields; // object holding billing data
  status: OrderStatus;
  amount: number;
  date_drafted: Date;
  date_updated: Date;
  // Optional fields are useful for the front end, but the database will assign 'null' to them
  // On fetch, these fields come back null so we have to destruct the objects and set them to undefined if they are null
  date_submitted: Date | null;
  date_shipped: Date | null;
  date_delivered: Date | null;
};

// front-end only
export type NewOrder = Omit<Order, "order_id" | "order_number" | "amount">;
// need a config object where all fields are optional
export type OrderItem = {
  order_item_id: number;
  order_id: string;
  product_type_id: string; // uuid of the product type
  // need product type name
  product_config: any; // jsonb
  quantity: number;
  note?: string;
};

export type NewOrderItem = Omit<OrderItem, "order_item_id" | "order_id">;

export type OrderInvoice = {
  order_invoice_id: string;
  // user_id of the user that entered the order
  created_by: string;
  order_id: string;
  customer_id: string;
  invoice_number: string;
  status: string;
  amount: number;
  date_created: Date;
};
